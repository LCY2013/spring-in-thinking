JPA
jpa官方地址: https://github.com/eclipse-ee4j/jpa-api

1、一套 API 标准定义了一套接口，在 javax.persistence 的包下面，用来操作实体对象，执行 CRUD 操作，
  而实现的框架（Hibernate）替代我们完成所有的事情，让开发者从烦琐的 JDBC 和 SQL 代码中解脱出来，
  更加聚焦自己的业务代码，并且使架构师架构出来的代码更加可控。

2、定义了一套基于对象的 SQL：Java Persistence Query Language（JPQL），像 Hibernate 一样，
  我们通过写面向对象（JPQL）而非面向数据库的查询语言（SQL）查询数据，避免了程序与数据库 SQL 语句耦合严重，
  比较适合跨数据源的场景（一会儿 MySQL，一会儿 Oracle 等）。

3、ORM（Object/Relational Metadata）对象注解映射关系，
    JPA 直接通过注解的方式来表示 Java 的实体对象及元数据对象和数据表之间的映射关系，
    框架将实体对象与 Session 进行关联，通过操作 Session 中不通实体的状态，
    从而实现数据库的操作，并实现持久化到数据库表中的操作，与 DB 实现同步。

Spring Data
    1、Spring Data 项目是从 2010 年开发发展起来的，Spring Data 利用一个大家熟悉的、一致的、
        基于“注解”的数据访问编程模型，做一些公共操作的封装，它可以轻松地让开发者使用数据库访问技术，
        包括关系数据库、非关系数据库（NoSQL）。同时又有不同的数据框架的实现，
        保留了每个底层数据存储结构的特殊特性。

    2、Spring Data Common 是 Spring Data 所有模块的公共部分，该项目提供了基于 Spring 的共享基础设施，
        它提供了基于 repository 接口以 DB 操作的一些封装，以及一个坚持在 Java 实体类上标注元数据的模型。

    3、Spring Data 不仅对传统的数据库访问技术如 JDBC、Hibernate、JDO、TopLick、JPA、MyBatis
        做了很好的支持和扩展、抽象、提供方便的操作方法，还对 MongoDb、KeyValue、Redis、LDAP、Cassandra
        等非关系数据的 NoSQL 做了不同的实现版本，方便我们开发者触类旁通。

Spring Data Common
    定义了很多公用的接口和一些相对数据操作的公共实现（如分页排序、结果映射、Autiting 信息、事务等），
    而 Spring Data JPA 就是 Spring Data Common 的关系数据库的查询实现。

    数据库连接用的是 JDBC，连接池用的是 HikariCP，强依赖 Hibernate；
    Spring Boot Starter Data JPA 依赖 Spring Data JPA；
    而 Spring Data JPA 依赖 Spring Data Commons。

    Repository
        Repository 是 Spring Data Common 里面的顶级父类接口，操作 DB 的入口类。
        首先介绍 Repository 接口的源码、类层次关系和使用实例。
            package org.springframework.data.repository;
            import org.springframework.stereotype.Indexed;
            @Indexed
            public interface Repository<T, ID> {
            }
        Repository 是 Spring Data 里面进行数据库操作顶级的抽象接口，里面什么方法都没有，
        但是如果任何接口继承它，就能得到一个 Repository，还可以实现 JPA 的一些默认实现方法。
        Spring 利用 Respository 作为 DAO 操作的 Type，以及利用 Java 动态代理机制就可以实现很多功能，
        比如为什么接口就能实现 DB 的相关操作？这就是 Spring 框架的高明之处。

        Spring 在做动态代理的时候，只要是它的子类或者实现类，再利用 T 类以及 T 类的 主键 ID 类型作为泛型的类型参数，
        就可以来标记出来、并捕获到要使用的实体类型，就能帮助使用者进行数据库操作。

        Repository 类层次关系
        下面我们来根据这个基类 Repository 接口，顺藤摸瓜看看 Spring Data JPA 里面都有什么。
        打开类 Repository，fn + control + H :
            1、ReactiveCrudRepository： 这条线是响应式编程，主要支持当前 NoSQL 方面的操作，因为这方面大部分操作都是分布式的，
                        所以由此我们可以看出 Spring Data 想统一数据操作的“野心”，即想提供关于所有 Data 方面的操作。
                        目前 Reactive 主要有 Cassandra、MongoDB、Redis 的实现。

            2、RxJava2CrudRepository： 这条线是为了支持 RxJava 2 做的标准响应式编程的接口。

            3、CoroutineCrudRepository： 这条继承关系链是为了支持 Kotlin 语法而实现的。

            4、CrudRepository： 这条继承关系是 JPA Crud 相关的操作接口。

        7 个大 Repository 接口：
            Repository(org.springframework.data.repository)，没有暴露任何方法；

            CrudRepository(org.springframework.data.repository)，简单的 Curd 方法；

            PagingAndSortingRepository(org.springframework.data.repository)，带分页和排序的方法；

            QueryByExampleExecutor(org.springframework.data.repository.query)，简单 Example 查询；

            JpaRepository(org.springframework.data.jpa.repository)，JPA 的扩展方法；

            JpaSpecificationExecutor(org.springframework.data.jpa.repository)，JpaSpecification 扩展查询；

            QueryDslPredicateExecutor(org.springframework.data.querydsl)，QueryDsl 的封装。

        两大 Repository 实现类：
            SimpleJpaRepository(org.springframework.data.jpa.repository.support)，JPA 所有接口的默认实现类；
                关系数据库的所有 Repository 接口的实现类就是 SimpleJpaRepository，如果有些业务场景需要进行扩展了，可以继续继承此类，如 QueryDsl 的扩展（虽然不推荐使用了，但可以参考它的做法，自定义自己的 SimpleJpaRepository）
                看出 SimpleJpaRepository 的实现机制，是通过 EntityManger 进行实体的操作，而 JpaEntityInforMation 里面存在实体的相关信息和 Crud 方法的元数据等。
                利用 Java 动态代理机制帮我们生成的实现类，那么关于动态代理的实现，我们可以在 RepositoryFactorySupport 设置一个断点，启动的时候，在断点处就会发现 UserRepository 的接口会被动态代理成 SimpleJapRepository 的实现。
                代码位置: org.springframework.data.repository.core.support.RepositoryFactorySupport.getRepository
                需要注意的是每一个 Repository 的子类，都会通过这里的动态代理生成实现类。
                动态代理的实现类是SimpleJpaRepository，代理类集成了自定义的接口Repository、Repository、以及TransactionalProxy接口。

            QueryDslJpaRepository(org.springframework.data.jpa.repository.support)，QueryDsl 的实现类。

Spring Data JPA 的最大特色 - 方法名定义查询方法（Defining Query Methods）DQM来做 CRUD 操作

    DQM的两种语法:
        1、直接通过方法名就可以实现

        2、@Query 手动在方法上定义

    定义查询方法的配置和使用方法
        1、User 实体的 UserRepository 继承 Spring Data Common 里面的 Repository 接口或者它的子接口
            interface UserRepository extends CrudRepository<User, Long> {
                 User findByEmailAddress(String emailAddress);
            }

        2、对于 Service 层就可以直接使用 UserRepository 接口
            @Service
            public class UserServiceImpl{
                @Autowired
                UserRepository userRepository;
                public void testJpa() {
                    userRepository.deleteAll();
                    userRepository.findAll();
                    userRepository.findByEmailAddress("fufeng@magic.com");
                }
            }

        如果需要限制一些Repository的功能，那么可以定义一个基类Repository，定义需要暴露的方法名称
            @NoRepositoryBean
            interface BaseRepository<T, ID extends Serializable> extends Repository<T, ID> {
                T findOne(ID id);
                T save(T entity);
            }
            interface UserRepository extends BaseRepository<User, Long> {
                 User findByEmailAddress(String emailAddress);
            }

        结论:
            1、CustomerRepository Extends Repository 接口可以实现 Defining Query Methods 的功能

            2、继承其他 Repository 的子接口，或者自定义子接口，可以选择性地暴露 SimpleJpaRepository 里面已经实现的基础公用方法

    方法的查询策略设置 - 选择具体的DQM语法
        目前在实际生产中还没有遇到要修改默认策略的情况，但我们必须要知道有这样的配置方法，做到心中有数，这样我们才能知道为什么方法名可以，@Query 也可以。

        通过 @EnableJpaRepositories 注解来配置方法的查询策略:
            @EnableJpaRepositories(queryLookupStrategy= QueryLookupStrategy.Key.CREATE_IF_NOT_FOUND)

            QueryLookupStrategy.Key 的值共 3 个，具体如下：
                Create：直接根据方法名进行创建，规则是根据方法名称的构造进行尝试，一般的方法是从方法名中删除给定的一组已知前缀，并解析该方法的其余部分。
                    如果方法名不符合规则，启动的时候会报异常，这种情况可以理解为，即使配置了 @Query 也是没有用的。

                USE_DECLARED_QUERY：声明方式创建，启动的时候会尝试找到一个声明的查询，如果没有找到将抛出一个异常，可以理解为必须配置 @Query。

                CREATE_IF_NOT_FOUND：这个是默认的，除非有特殊需求，可以理解为这是以上 2 种方式的兼容版。
                    先用声明方式（@Query）进行查找，如果没有找到与方法相匹配的查询，那用 Create 的方法名创建规则创建一个查询；
                    这两者都不满足的情况下，启动就会报错。

            springboot 项目配置如下:
                @EnableJpaRepositories(queryLookupStrategy= QueryLookupStrategy.Key.CREATE_IF_NOT_FOUND)
                public class Example1Application {
                   public static void main(String[] args) {
                      SpringApplication.run(Example1Application.class, args);
                   }
                }

    Defining Query Method（DQM）语法
        该语法是：带查询功能的方法名由查询策略（关键字）+ 查询字段 + 一些限制性条件组成，具有语义清晰、功能完整的特性，我们实际工作中 80% 的 API 查询都可以简单实现。

        举例如下:
            interface PersonRepository extends Repository<User, Long> {
               // and 的查询关系
               List<User> findByEmailAddressAndLastname(EmailAddress emailAddress, String lastname);
               // 包含 distinct 去重，or 的 sql 语法
               List<User> findDistinctPeopleByLastnameOrFirstname(String lastname, String firstname);
               // 根据 lastname 字段查询忽略大小写
               List<User> findByLastnameIgnoreCase(String lastname);
               // 根据 lastname 和 firstname 查询 equal 并且忽略大小写
               List<User> findByLastnameAndFirstnameAllIgnoreCase(String lastname, String firstname);
               // 对查询结果根据 lastname 排序，正序
               List<User> findByLastnameOrderByFirstnameAsc(String lastname);
               // 对查询结果根据 lastname 排序，倒序
               List<User> findByLastnameOrderByFirstnameDesc(String lastname);
            }

        总结:
            1、方法名的表达式通常是实体属性连接运算符的组合，如 And、or、Between、LessThan、GreaterThan、Like 等属性连接运算表达式，
                不同的数据库（NoSQL、MySQL）可能产生的效果不一样，如果遇到问题，我们可以打开 SQL 日志观察。

            2、IgnoreCase 可以针对单个属性（如 findByLastnameIgnoreCase(…)），也可以针对查询条件里面所有的实体属性忽略大小写
                （所有属性必须在 String 情况下，如 findByLastnameAndFirstnameAllIgnoreCase(…)）。

            3、OrderBy 可以在某些属性的排序上提供方向（Asc 或 Desc），称为静态排序，
                也可以通过一个方便的参数 Sort 实现指定字段的动态排序的查询方法（如 repository.findAll(Sort.by(Sort.Direction.ASC, "myField"))）。

        除此之外，JPA 还支持read、get、query、stream、count、exists、delete、remove等前缀，如字面意思一样。
        举例如下:
            interface UserRepository extends CrudRepository<User, Long> {
                 long countByLastname(String lastname);//查询总数
                 long deleteByLastname(String lastname);//根据一个字段进行删除操作，并返回删除行数
                 List<User> removeByLastname(String lastname);//根据Lastname删除一堆User,并返回删除的User
            }

    ----> 处理源码类，具体通过正则表达式解析匹配关键字
            org.springframework.data.repository.query.parser.PartTree 查看相关源码的逻辑和处理方法
            org.springframework.data.repository.query.parser.PartTree.Subject

            org.springframework.data.repository.query.parser.Part.Type 定义关键字

    特定类型的参数：Sort 排序和 Pageable 分页
        Spring Data JPA 为了方便我们排序和分页，支持了两个特殊类型的参数：Sort 和 Pageable。

        举例如下:
            方法一: Page<User> findByLastname(String lastname, Pageable pageable);//根据分页参数查询User，返回一个带分页结果的Page
            方法二: Slice<User> findByLastname(String lastname, Pageable pageable);//我们根据分页参数返回一个Slice的user结果
            方法三: List<User> findByLastname(String lastname, Sort sort);//根据排序结果返回一个List
            方法四: List<User> findByLastname(String lastname, Pageable pageable);//根据分页参数返回一个List对象

            方法一：允许将 org.springframework.data.domain.Pageable 实例传递给查询方法，将分页参数添加到静态定义的查询中，通过 Page 返回的结果得知可用的元素和页面的总数。
                这种分页查询方法可能是昂贵的（会默认执行一条 count 的 SQL 语句），所以用的时候要考虑一下使用场景。

            方法二：返回结果是 Slice，因为只知道是否有下一个 Slice 可用，而不知道 count，
                所以当查询较大的结果集时，只知道数据是足够的，也就是说用在业务场景中时不用关心一共有多少页。

            方法三：如果只需要排序，需在 org.springframework.data.domain.Sort 参数中添加一个参数，正如上面看到的，只需返回一个 List 也是有可能的。

            方法四：排序选项也通过 Pageable 实例处理，在这种情况下，Page 将不会创建构建实际实例所需的附加元数据（即不需要计算和查询分页相关数据），
                而仅仅用来做限制查询给定范围的实体。

        Pageable 实现子类 - org.springframework.data.domain.PageRequest
            举例如下:
                //查询user里面的lastname=jk的第一页，每页大小是20条；并会返回一共有多少页的信息
                Page<User> users = userRepository.findByLastname("jk",PageRequest.of(1, 20));
                //查询user里面的lastname=jk的第一页的20条数据，不知道一共多少条
                Slice<User> users = userRepository.findByLastname("jk",PageRequest.of(1, 20));
                //查询出来所有的user里面的lastname=jk的User数据，并按照name正序返回List
                List<User> users = userRepository.findByLastname("jk",new Sort(Sort.Direction.ASC, "name"))
                //按照createdAt倒序，查询前一百条User数据
                List<User> users = userRepository.findByLastname("jk",PageRequest.of(0, 100, Sort.Direction.DESC, "createdAt"));

    限制查询结果 First 和 Top
        想直接查询前几条数据，也不需要动态排序，那么就可以简单地在方法名字中使用 First 和 Top 关键字，来限制返回条数。

            举例如下:
                User findFirstByOrderByLastnameAsc();
                User findTopByOrderByAgeDesc();
                List<User> findDistinctUserTop3ByLastname(String lastname, Pageable pageable);
                List<User> findFirst10ByLastname(String lastname, Sort sort);
                List<User> findTop10ByLastname(String lastname, Pageable pageable);

        注意事项:
            查询方法在使用 First 或 Top 时，数值可以追加到 First 或 Top 后面，指定返回最大结果的大小。

            如果数字被省略，则假设结果大小为 1。

            限制表达式也支持 Distinct 关键字。

            支持将结果包装到 Optional 中。

            如果将 Pageable 作为参数，以 Top 和 First 后面的数字为准，即分页将在限制结果中应用。

    NULL 的情况作了哪些支持
        @NonNull、@NonNullApi、@Nullable

        从 Spring Data 2.0 开始，JPA 新增了@NonNull @NonNullApi @Nullable，是对 null 的参数和返回结果做的支持:
            @NonNullApi：在包级别用于声明参数，以及返回值的默认行为是不接受或产生空值的。

            @NonNull：用于不能为空的参数或返回值（在 @NonNullApi 适用的参数和返回值上不需要）。

            @Nullable：用于可以为空的参数或返回值。

            使用案例如下:
                在自己的 Repository 所在 package 的 package-info.java 类里面做如下声明：
                @org.springframework.lang.NonNullApi
                package com.my.repository;

                com.my.repository 下面的 UserRepository 实现如下：
                package com.my.repository;
                interface UserRepository extends Repository<User, Long> {
                  User getByEmailAddress(EmailAddress emailAddress);
                }
                当 emailAddress 参数为 null 的时候就会抛异常，当返回结果为 null 的时候也会抛异常。因为我们在package 的 package-info.java里面指定了NonNullApi，所有返回结果和参数不能为 Null。

                //当我们添加@Nullable 注解之后，参数和返回结果这个时候就都会允许为 null 了；
                @Nullable
                User findByEmailAddress(@Nullable EmailAddress emailAddress);
                //返回结果允许为 null,参数不允许为 null 的情况
                Optional<User> findOptionalByEmailAddress(EmailAddress emailAddress);

    DQM 应用到其他地方

        在实际工作中，也可以将方法名（非常语义化的 repository 里面所定义方法命名规范）的强制约定规范运用到 controller 和 service 层，这样全部统一后，可以减少很多的沟通成本。

        定一个BaseService接口
            public interface BaseService<T, ID> {
                Class<T> getDomainClass();
                <S extends T> S save(S entity);
                <S extends T> List<S> saveAll(Iterable<S> entities);
                void delete(T entity);
                void deleteById(ID id);
                void deleteAll();
                void deleteAll(Iterable<? extends T> entities);
                void deleteInBatch(Iterable<T> entities);
                void deleteAllInBatch();
                T getOne(ID id);
                <S extends T> Optional<S> findOne(Example<S> example);
                Optional<T> findById(ID id);
                List<T> findAll();
                List<T> findAll(Sort sort);
                Page<T> findAll(Pageable pageable);
                <S extends T> List<S> findAll(Example<S> example);
                <S extends T> List<S> findAll(Example<S> example, Sort sort);
                <S extends T> Page<S> findAll(Example<S> example, Pageable pageable);
                List<T> findAllById(Iterable<ID> ids);
                long count();
                <S extends T> long count(Example<S> example);
                <S extends T> boolean exists(Example<S> example);
                boolean existsById(ID id);
                void flush();
                <S extends T> S saveAndFlush(S entity);
            }

            public class BaseServiceImpl<T, ID, R extends JpaRepository<T, ID>> implements BaseService<T, ID> {
                private static final Map<Class, Class> DOMAIN_CLASS_CACHE = new ConcurrentHashMap<>();
                private final R repository;
                public BaseServiceImpl(R repository) {
                    this.repository = repository;
                }
                @Override
                public Class<T> getDomainClass() {
                    Class thisClass = getClass();
                    Class<T> domainClass = DOMAIN_CLASS_CACHE.get(thisClass);
                    if (Objects.isNull(domainClass)) {
                        domainClass = GenericsUtils.getGenericClass(thisClass, 0);
                        DOMAIN_CLASS_CACHE.putIfAbsent(thisClass, domainClass);
                    }
                    return domainClass;
                }
                protected R getRepository() {
                    return repository;
                }
                @Override
                public <S extends T> S save(S entity) {
                    return repository.save(entity);
                }
                @Override
                public <S extends T> List<S> saveAll(Iterable<S> entities) {
                    return repository.saveAll(entities);
                }
                @Override
                public void delete(T entity) {
                    repository.delete(entity);
                }
                @Override
                public void deleteById(ID id) {
                    repository.deleteById(id);
                }
                @Override
                public void deleteAll() {
                    repository.deleteAll();
                }
                @Override
                public void deleteAll(Iterable<? extends T> entities) {
                    repository.deleteAll(entities);
                }
                @Override
                public void deleteInBatch(Iterable<T> entities) {
                    repository.deleteInBatch(entities);
                }
                @Override
                public void deleteAllInBatch() {
                    repository.deleteAllInBatch();
                }
                @Override
                public T getOne(ID id) {
                    return repository.getOne(id);
                }
                @Override
                public <S extends T> Optional<S> findOne(Example<S> example) {
                    return repository.findOne(example);
                }
                @Override
                public Optional<T> findById(ID id) {
                    return repository.findById(id);
                }
                @Override
                public List<T> findAll() {
                    return repository.findAll();
                }
                @Override
                public List<T> findAll(Sort sort) {
                    return repository.findAll(sort);
                }
                @Override
                public Page<T> findAll(Pageable pageable) {
                    return repository.findAll(pageable);
                }
                @Override
                public <S extends T> List<S> findAll(Example<S> example) {
                    return repository.findAll(example);
                }
                @Override
                public <S extends T> List<S> findAll(Example<S> example, Sort sort) {
                    return repository.findAll(example, sort);
                }
                @Override
                public <S extends T> Page<S> findAll(Example<S> example, Pageable pageable) {
                    return repository.findAll(example, pageable);
                }
                @Override
                public List<T> findAllById(Iterable<ID> ids) {
                    return repository.findAllById(ids);
                }
                @Override
                public long count() {
                    return repository.count();
                }
                @Override
                public <S extends T> long count(Example<S> example) {
                    return repository.count(example);
                }
                @Override
                public <S extends T> boolean exists(Example<S> example) {
                    return repository.exists(example);
                }
                @Override
                public boolean existsById(ID id) {
                    return repository.existsById(id);
                }
                @Override
                public void flush() {
                    repository.flush();
                }
                @Override
                public <S extends T> S saveAndFlush(S entity) {
                    return repository.saveAndFlush(entity);
                }
            }

    Repository 的返回结果有哪些？
        实现的方法，以及父类接口的方法和返回类型包括：Optional、Iterable、List、Page、Long、Boolean、Entity 对象等。

        Spring Data 里面定义了一个特殊的子类 Steamable，Streamable 可以替代 Iterable 或任何集合类型。
        它还提供了方便的方法来访问 Stream，可以直接在元素上进行 ….filter(…) 和 ….map(…) 操作，并将 Streamable 连接到其他元素。

        自定义 Streamable 流程如下:
            class Product { (1)
              MonetaryAmount getPrice() { … }
            }
            @RequiredArgsConstructor(staticName = "of")
            class Products implements Streamable<Product> { (2)
              private Streamable<Product> streamable;
              public MonetaryAmount getTotal() { (3)
                return streamable.stream() //
                  .map(Priced::getPrice)
                  .reduce(Money.of(0), MonetaryAmount::add);
              }
            }
            interface ProductRepository implements Repository<Product, Long> {
              Products findAllByDescriptionContaining(String text); (4)
            }
            （1）Product 实体，公开 API 以访问产品价格。

            （2）Streamable<Product> 的包装类型可以通过 Products.of(…) 构造（通过 Lombok 注解创建的工厂方法）。

            （3）包装器类型在 Streamable<Product> 上公开了计算新值的其他 API。

            （4）可以将包装器类型直接用作查询方法返回类型。无须返回 Stremable<Product> 并将其手动包装在存储库 Client 端中。

           源码位置:
                // 判断方法返回值是否是一个Streamable类型
                org.springframework.data.repository.core.support.QueryExecutionResultHandler.requiresConversion

    Repository 对 Feature/CompletableFuture 异步返回结果的支持?
        @Async
        Future<User> getByName(String name);
        注意事项:
            在实际工作中，直接在 Repository 这一层使用异步方法的场景不多，一般都是把异步注解放在 Service 的方法上面，这样的话，可以有一些额外逻辑，如发短信、发邮件、发消息等配合使用；
            使用异步的时候一定要配置线程池；
            万一失败我们会怎么处理？关于事务是怎么处理的呢？

    对 Reactive 支持 flux 与 Mono?
        JPA里面没有做相关的Reactive 的实现，但是本身Spring Data Common里面对 Reactive 是支持的，
        提供了相关接口，但是具体实现是在Spring-data-common的子模块中有实现。

    返回结果支持总结？
        ResultProcessor 类的源码
            org.springframework.data.repository.query.ResultProcessor.processResult(java.lang.Object, org.springframework.core.convert.converter.Converter<java.lang.Object,java.lang.Object>)

    org.springframework.data.mapping.model.PreferredConstructorDiscoverer.Discoverers.discover

    JPA 获取返回集的三种方式:
        1、通过定义一个只需要某些字段的实体对象，比如User
            Class UserName {
                private String name;
            }
           然后在对这个实体做一个Repository
           interface UserNameRepository extends Repository{

           }
        2、通过定义一个dto的方式直接返回
            class UserNameDto {
                private String name;
            }
            interface UserRepository extends JpaRepository{
                UserNameDto findOneByName(String name);
            }
        3、通过定义一个返回pojo的接口（推荐）
            interface UserNamePojo{
                String getName();
            }
            interface UserRepository extends JpaRepository{
                UserNamePojo findOneByName(String name);
            }
            源码实现位置:
               org.hibernate.query.criteria.internal.QueryStructure.render

    @Query 的魔法

        JpaQueryLookupStrategy 关键源码剖析:
            org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy
            org.springframework.data.repository.core.support.QueryExecutorMethodInterceptor

            第一步: org.springframework.data.repository.core.support.QueryExecutorMethodInterceptor.lookupQuery
            第二步: org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy.CreateIfNotFoundQueryLookupStrategy.resolveQuery
            第三步: org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy.DeclaredQueryLookupStrategy.resolveQuery
            第四步: org.springframework.data.jpa.repository.query.JpaQueryFactory.fromQueryAnnotation
            第五步: org.springframework.data.jpa.repository.query.JpaQueryMethod.getAnnotatedQuery
            第六步: org.springframework.data.jpa.repository.query.JpaQueryMethod.getAnnotationValue
            第七步: org.springframework.data.jpa.repository.query.JpaQueryMethod.getMergedOrDefaultAnnotationValue

        内涵字段的含义
            package org.springframework.data.jpa.repository;
            public @interface Query {
               /**
                * 指定JPQL的查询语句。（nativeQuery=true的时候，是原生的Sql语句）
            	*/
               String value() default "";
               /**
            	* 指定count的JPQL语句，如果不指定将根据query自动生成。
                * （如果当nativeQuery=true的时候，指的是原生的Sql语句）
                */
               String countQuery() default "";
               /**
                * 根据哪个字段来count，一般默认即可。
            	*/
               String countProjection() default "";
               /**
                * 默认是false，表示value里面是不是原生的sql语句
            	*/
               boolean nativeQuery() default false;
               /**
                * 可以指定一个query的名字，必须唯一的。
            	* 如果不指定，默认的生成规则是：
                * {$domainClass}.${queryMethodName}
                */
               String name() default "";
               /*
                * 可以指定一个count的query的名字，必须唯一的。
            	* 如果不指定，默认的生成规则是：
                * {$domainClass}.${queryMethodName}.count
                */
               String countName() default "";
            }

    JPQL 官方网址: https://docs.oracle.com/html/E13946_04/ejb3_langref.html

    @Param 用法

        @Entity
        @Data
        @Builder
        @AllArgsConstructor
        @NoArgsConstructor
        public class PersonExtend { //用户扩展信息表
           @Id
           @GeneratedValue(strategy= GenerationType.AUTO)
           private Long id;
           private Long userId;
           private String idCard;
           private Integer ages;
           private String studentNumber;
        }
        @Entity
        @Data
        @Builder
        @AllArgsConstructor
        @NoArgsConstructor
        public class Person { //用户基本信息表
           @Id
           @GeneratedValue(strategy= GenerationType.AUTO)
           private Long id;
           private String name;
           private String email;
           @Version
           private Long version;
           private String sex;
           private String address;
        }

    @Query 动态查询解决方法

JPA - jsr338 Java Entity persistent (https://download.oracle.com/otn-pub/jcp/persistence-2_2-mrel-spec/JavaPersistence.pdf)

    Entity 使用:
        1、实体是直接进行数据库持久化操作的领域对象（即一个简单的 POJO，可以按照业务领域划分），必须通过 @Entity 注解进行标示。

        2、实体必须有一个 public 或者 protected 的无参数构造方法。

        3、持久化映射的注解可以标示在 Entity 的字段 field 上，也可以将持久化注解运用在 Entity 里面的 get/set 方法上，通常我们是放在 get 方法上，需要注意的是，在同一个 Entity 里面只能有一种方式生效，也就是说，注解要么全部写在 field 上面，要么就全部写在 Property方法上面。

    Entity 使用注意项:
        1、只要是在 @Entity 的实体里面被注解标注的字段，都会被映射到数据库中，除了使用 @Transient 注解的字段之外。

        2、实体里面必须要有一个主键，主键标示的字段可以是单个字段，也可以是复合主键字段。

    @Entity注解 用于定义对象将会成为被 JPA 管理的实体，必填，将字段映射到指定的数据库表中，直接用在实体类。

    @Table注解 用于指定数据库的表名，表示此实体对应的数据库里面的表名，非必填，默认表名和 entity 名字一样。

    @Access注解 用于指定 entity 里面的注解是写在字段上面，还是 get/set 方法上面生效，非必填。在默认不填写的情况下，当实体里面的第一个注解出现在字段上或者 get/set 方法上面，就以第一次出现的方式为准。

    @Id注解 定义属性为数据库的主键，一个实体里面必须有一个主键，但不一定是这个注解，可以和 @GeneratedValue 配合使用或成对出现。

    @GeneratedValue注解 主键生成策略。
        public enum GenerationType {
            //通过表产生主键，框架借由表模拟序列产生主键，使用该策略可以使应用更易于数据库移植。
            TABLE,
            //通过序列产生主键，通过 @SequenceGenerator 注解指定序列名， MySql 不支持这种方式；
            SEQUENCE,
            //采用数据库ID自增长， 一般用于mysql数据库
            IDENTITY,
            //JPA 自动选择合适的策略，是默认选项；
            AUTO
        }

    @Enumerated注解 这个注解很好用，因为它对 enum 提供了下标和 name 两种方式，用法直接映射在 enum 枚举类型的字段上。
        @Target({METHOD, FIELD}) //作用在方法和字段上
        public @interface Enumerated {
        //枚举映射的类型，默认是ORDINAL（即枚举字段的下标）。
            EnumType value() default ORDINAL;
        }
        public enum EnumType {
            //映射枚举字段的下标
            ORDINAL,
            //映射枚举的Name
            STRING
        }
        举例:
            //有一个枚举类，用户的性别
            public enum Gender {
                MAIL("男性"), FMAIL("女性");
                private String value;
                private Gender(String value) {
                    this.value = value;
                }
            }
            //实体类@Enumerated的写法如下
            @Entity
            @Table(name = "tb_user")
            public class User implements Serializable {
                @Enumerated(EnumType.STRING)
                @Column(name = "user_gender")
                private Gender gender;
                ...
            }
            数据库里面的值会变成 MAIL/FMAIL，而不是男性/女性

    @Basic注解 表示属性是到数据库表的字段的映射，如果实体的字段上没有任何注解，默认即为 @Basic，也就是说默认所有的字段肯定是和数据库进行映射的，并且默认为 Eager 类型。
        public @interface Basic {
            //可选，EAGER（默认）：立即加载；LAZY：延迟加载。（LAZY主要应用在大字段上面）
            FetchType fetch() default EAGER;
            //可选。这个字段是否可以为null，默认是true。
            boolean optional() default true;
        }

    @Transient注解 表示该属性不是映射到数据库表的字段，表示非持久化属性。JPA 映射数据库的时候忽略它，与 @Basic 有相反的作用。也就是每个字段上面 @Transient 和 @Basic 必须二选一，而什么都不指定的话，默认是 @Basic。

    @Column注解 定义该属性对应数据库中的列名。
        public @interface Column {
            //数据库中的表的列名；可选，如果不填写认为字段名和实体属性名一样。
            String name() default "";
            //是否唯一。默认flase，可选。
            boolean unique() default false;
            //数据字段是否允许空。可选，默认true。
            boolean nullable() default true;
            //执行insert操作的时候是否包含此字段，默认，true，可选。
            boolean insertable() default true;
            //执行update的时候是否包含此字段，默认，true，可选。
            boolean updatable() default true;
            //表示该字段在数据库中的实际类型。
            String columnDefinition() default "";
            //数据库字段的长度，可选，默认255
            int length() default 255;
        }

    @Temporal注解 用来设置 Date 类型的属性映射到对应精度的字段，存在以下三种情况：
        @Temporal(TemporalType.DATE)映射为日期 // date （只有日期）

        @Temporal(TemporalType.TIME)映射为日期 // time （只有时间）

        @Temporal(TemporalType.TIMESTAMP)映射为日期 // date time （日期+时间）

    如何通过 @IdClass 做到联合主键？
        import lombok.AllArgsConstructor;
        import lombok.Builder;
        import lombok.Data;
        import lombok.NoArgsConstructor;
        import java.io.Serializable;
        @Data
        @Builder
        @AllArgsConstructor
        @NoArgsConstructor
        public class UserInfoID implements Serializable {
           private String name,telephone;
        }

        @Entity
        @Data
        @Builder
        @IdClass(UserInfoID.class)
        @AllArgsConstructor
        @NoArgsConstructor
        public class UserInfo {
           private Integer ages;
           @Id
           private String name;
           @Id
           private String telephone;
        }

        新建 UserInfoRepository 仓储
        import org.springframework.data.jpa.repository.JpaRepository;
        public interface UserInfoRepository extends JpaRepository<UserInfo,UserInfoID> {
        }

        新建测试用例
        import org.junit.jupiter.api.Test;
        import org.springframework.beans.factory.annotation.Autowired;
        import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
        import java.util.Optional;
        @DataJpaTest
        public class UserInfoRepositoryTest {
           @Autowired
           private UserInfoRepository userInfoRepository;
           @Test
           public void testIdClass() {
              userInfoRepository.save(UserInfo.builder().ages(1).name("fufeng").telephone("37348234743").build());
              Optional<UserInfo> userInfo = userInfoRepository.findById(UserInfoID.builder().name("fufeng").telephone("37348234743").build());
              System.out.println(userInfo.get());
           }
        }

    @Embeddable 与 @EmbeddedId 注解使用?
        @Data
        @Builder
        @AllArgsConstructor
        @NoArgsConstructor
        @Embeddable
        public class UserInfoEmbeddedID implements Serializable {
           private String name,telephone;
        }

        @Entity
        @Data
        @Builder
        @AllArgsConstructor
        @NoArgsConstructor
        public class UserInfoEmbedded {
           private Integer ages;
           @EmbeddedId
           private UserInfoID userInfoID;
           @Column(unique = true)
           private String uniqueNumber;
        }

    @IdClass 和 @EmbeddedId 的区别是什么？
        1、在使用的时候，Embedded 用的是对象，而 IdClass 用的是具体的某一个字段；

        2、二者的JPQL 也会不一样：
            1、用 @IdClass JPQL 的写法：SELECT u.name FROM UserInfo u

            2、用 @EmbeddedId 的 JPQL 的写法：select u.userInfoId.name FROM UserInfo u

    实体之间的继承关系如何实现？
        1、纯粹的继承，和表没关系，对象之间的字段共享。利用注解 @MappedSuperclass，协议规定父类不能是 @Entity。

        2、单表多态问题，同一张 Table，表示了不同的对象，通过一个字段来进行区分。利用@Inheritance(strategy = InheritanceType.SINGLE_TABLE)注解完成，只有父类有 @Table。

        3、多表多态，每一个子类一张表，父类的表拥有所有公用字段。通过@Inheritance(strategy = InheritanceType.JOINED)注解完成，父类和子类都是表，有公用的字段在父表里面。

        4、Object 的继承，数据库里面每一张表是分开的，相互独立不受影响。通过@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)注解完成，父类（可以是一张表，也可以不是）和子类都是表，相互之间没有关系。

    @Inheritance(strategy = InheritanceType.SINGLE_TABLE)
        import lombok.Data;
        import javax.persistence.*;
        @Entity(name="MainBook")
        @Data
        @Inheritance(strategy = InheritanceType.SINGLE_TABLE)
        @DiscriminatorColumn(name="color", discriminatorType = DiscriminatorType.STRING)
        public class MainBook {
           @Id
           @GeneratedValue(strategy= GenerationType.AUTO)
           private Long id;
           private String title;
        }

        import lombok.Data;
        import lombok.EqualsAndHashCode;
        import javax.persistence.DiscriminatorValue;
        import javax.persistence.Entity;
        @Entity
        @Data
        @EqualsAndHashCode(callSuper=false)
        @DiscriminatorValue("blue")
        public class BlueSubBook extends MainBook{
           private String blueMark;
        }

        //红皮书
        @Entity
        @DiscriminatorValue("red")
        @Data
        @EqualsAndHashCode(callSuper=false)
        public class RedSubBook extends MainBook {
           private String redMark;
        }

        import org.springframework.data.jpa.repository.JpaRepository;
        public interface RedSubBookRepository extends JpaRepository<RedSubBook,Long>{
        }

        import org.junit.jupiter.api.Test;
        import org.springframework.beans.factory.annotation.Autowired;
        import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
        @DataJpaTest
        public class RedSubBookRepositoryTest {
           @Autowired
           private RedSubBookRepository redSubBookRepository;
           @Test
           public void testRedSubBook() {
              RedSubBook sedSubBook = new RedSubBook();
              sedSubBook.setTitle("redbook");
              sedSubBook.setRedMark("redmark");
              sedSubBook.setId(1L);
              redSubBookRepository.saveAndFlush(redBook);
              RedSubBook r = redSubBookRepository.findById(1L).get();
              System.out.println(r.getId()+":"+r.getTitle()+":"+r.getRedMark());
           }
        }

    @Inheritance(strategy = InheritanceType.JOINED)
        import lombok.Data;
        import javax.persistence.*;
        @Entity(name="JoinBook")
        @Data
        @Inheritance(strategy = InheritanceType.JOINED)
        public class JoinBook {
           @Id
           @GeneratedValue(strategy= GenerationType.AUTO)
           private Long id;
           private String title;
        }

        import lombok.Data;
        import lombok.EqualsAndHashCode;
        import javax.persistence.Entity;
        import javax.persistence.PrimaryKeyJoinColumn;
        @Entity
        @Data
        @EqualsAndHashCode(callSuper=false)
        @PrimaryKeyJoinColumn(name = "book_id", referencedColumnName = "id")
        public class BlueJoinBook extends JoinBook{
           private String blueMark;
        }

        import lombok.Data;
        import lombok.EqualsAndHashCode;
        import javax.persistence.Entity;
        import javax.persistence.PrimaryKeyJoinColumn;
        @Entity
        @PrimaryKeyJoinColumn(name = "book_id", referencedColumnName = "id")
        @Data
        @EqualsAndHashCode(callSuper=false)
        public class RedJoinBook extends JoinBook {
           private String redMark;
        }

        import org.springframework.data.jpa.repository.JpaRepository;
        public interface RedJoinBookRepository extends JpaRepository<RedJoinBook,Long>{
        }

    @Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
        import lombok.Data;
        import javax.persistence.*;
        @Entity(name="PerBook")
        @Data
        @Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
        public class PerBook {
           @Id
           @GeneratedValue(strategy= GenerationType.AUTO)
           private Long id;
           private String title;
        }

        import lombok.Data;
        import lombok.EqualsAndHashCode;
        import javax.persistence.Entity;
        @Entity
        @Data
        @EqualsAndHashCode(callSuper=false)
        public class RedPerBook extends PerBook {
           private String redMark;
        }

        import lombok.Data;
        import lombok.EqualsAndHashCode;
        import javax.persistence.Entity;
        @Entity
        @Data
        @EqualsAndHashCode(callSuper=false)
        public class BluePerBook extends PerBook{
           private String blueMark;
        }

Entity 如何处理关联关系?

    实体与实体之间的关联关系一共分为四种，分别为 OneToOne、OneToMany、ManyToOne 和 ManyToMany，而实体之间的关联关系又分为双向的和单向的。

    OneToOne 关联关系

        @OneToOne 一般表示对象之间一对一的关联关系，它可以放在 field 上面，也可以放在 get/set 方法上面。其中 JPA 协议有规定，如果是配置双向关联，维护关联关系的是拥有外键的一方，而另一方必须配置 mappedBy；如果是单项关联，直接配置在拥有外键的一方即可。

        举例：user 表是用户的主信息，user_info 是用户的扩展信息，两者之间是一对一的关系。user_info 表里面有一个 user_id 作为关联关系的外键，如果是单项关联，写法如下：

            import lombok.AllArgsConstructor;
            import lombok.Builder;
            import lombok.Data;
            import lombok.NoArgsConstructor;
            import javax.persistence.*;
            @Entity
            @Data
            @Builder
            @AllArgsConstructor
            @NoArgsConstructor
            public class User {
               @Id
               @GeneratedValue(strategy= GenerationType.AUTO)
               private Long id;
               private String name;
               private String email;
               private String sex;
               private String address;
            }

            import lombok.*;
            import javax.persistence.*;
            @Entity
            @Data
            @Builder
            @AllArgsConstructor
            @NoArgsConstructor
            @ToString(exclude = "user")
            public class UserInfo {
               @Id
               @GeneratedValue(strategy= GenerationType.AUTO)
               private Long id;
               private Integer ages;
               private String telephone;
               @OneToOne //维护user的外键关联关系，配置一对一
               private User user;
            }

        如果是双项关联，写法如下：

            import lombok.AllArgsConstructor;
            import lombok.Builder;
            import lombok.Data;
            import lombok.NoArgsConstructor;
            import javax.persistence.*;
            @Entity
            @Data
            @Builder
            @AllArgsConstructor
            @NoArgsConstructor
            public class User {
               @Id
               @GeneratedValue(strategy= GenerationType.AUTO)
               private Long id;
               private String name;
               private String email;
               private String sex;
               private String address;
               @OneToOne(mappedBy = "user")
               private UserInfo userInfo;
            }

            import lombok.*;
            import javax.persistence.*;
            @Entity
            @Data
            @Builder
            @AllArgsConstructor
            @NoArgsConstructor
            @ToString(exclude = "user")
            public class UserInfo {
               @Id
               @GeneratedValue(strategy= GenerationType.AUTO)
               private Long id;
               private Integer ages;
               private String telephone;
               @OneToOne //维护user的外键关联关系，配置一对一
               private User user;
            }

        源码分析:

            public @interface OneToOne {
                //表示关系目标实体，默认该注解标识的返回值的类型的类。
                Class targetEntity() default void.class;
                //cascade 级联操作策略，就是我们常说的级联操作
                CascadeType[] cascade() default {};
                //数据获取方式EAGER(立即加载)/LAZY(延迟加载)
                FetchType fetch() default EAGER;
                //是否允许为空，默认是可选的，也就表示可以为空；
                boolean optional() default true;
                //关联关系被谁维护的一方对象里面的属性名字。 双向关联的时候必填
                String mappedBy() default "";
                //当被标识的字段发生删除或者置空操作之后，是否同步到关联关系的一方，即进行通过删除操作，默认flase，注意与CascadeType.REMOVE 级联删除的区别
                boolean orphanRemoval() default false;
            }

        mappedBy 注意事项:
            只有关联关系的维护方才能操作两个实体之间外键的关系，被维护方即使设置了维护方属性进行存储也不会更新外键关联。

            mappedBy 不能与 @JoinColumn 或者 @JoinTable 同时使用，因为没有意义，关联关系不在这里面维护。

            此外，mappedBy 的值是指另一方的实体里面属性的字段，而不是数据库字段，也不是实体的对象的名字。也就是维护关联关系的一方属性字段名称，或者加了 @JoinColumn / @JoinTable 注解的属性字段名称。如上面的 User 例子 user 里面 mappedBy 的值，就是 UserInfo 里面的 user 字段的名字。

        CascadeType 属性用法
            在 CascadeType 的用法中，CascadeType 的枚举值只有五个，分别如下：

            CascadeType.PERSIST 级联新建

            CascadeType.REMOVE 级联删除

            CascadeType.REFRESH 级联刷新

            CascadeType.MERGE 级联更新

            CascadeType.ALL 四项全选

        orphanRemoval 属性用法
            orphanRemoval 表示当关联关系被删除的时候，是否应用级联删除，默认 false。

    主键和外键都是同一个字段

        假设 user 表是主表，user_info 的主键是 user_id，并且 user_id=user 是表里面的 id，那我们应该怎么写？

        public class UserInfo implements Serializable {
           @Id
           private Long userId;
           private Integer ages;
           private String telephone;
           @MapsId  // 作用是把关联关系实体里面的 ID（默认）值 copy 到 @MapsId 标注的字段上面（这里指的是 user_id 字段）
           @OneToOne(cascade = {CascadeType.PERSIST},orphanRemoval = true)
           private User user;
        }

    @OneToOne 延迟加载，只需要 ID 值

        在 @OneToOne 延迟加载的情况下，我们假设只想查下 user_id，而不想查看 user 表其他的信息，因为当前用不到，可以有以下几种做法：

        第一种做法：还是 User 实体不变，改一下 UserInfo 对象，如下所示：
            import lombok.*;
            import javax.persistence.*;
            @Entity
            @Data
            @Builder
            @AllArgsConstructor
            @NoArgsConstructor
            @ToString(exclude = "user")
            public class UserInfo{
               @Id
               @GeneratedValue(strategy= GenerationType.AUTO)
               private Long id;
               private Integer ages;
               private String telephone;
               @MapsId
               @OneToOne(cascade = {CascadeType.PERSIST},orphanRemoval = true,fetch = FetchType.LAZY)
               private User user;
            }

            @OneToOne 上面我们添加 @MapsId 注解

            @OneToOne 里面的 fetch = FetchType.LAZY 设置延迟加载

        第二种做法：只要在 UserInfo 对象里面直接去掉 @OneToOne 关联关系，新增下面的字段即可。
            import lombok.*;
            import javax.persistence.*;
            @Entity
            @Data
            @Builder
            @AllArgsConstructor
            @NoArgsConstructor
            @ToString(exclude = "user")
            public class UserInfo{
               @Id
               @GeneratedValue(strategy= GenerationType.AUTO)
               private Long id;
               private Integer ages;
               private String telephone;
               @Column(name = "user_id")
               private Long userId;
            }

        第三做法：利用 Hibernate，它给我们提供了一种字节码增强技术，通过编译器改变 class 解决了延迟加载问题。这种方式有点复杂，需要在编译器引入 hibernateEnhance 的相关 jar 包，以及编译器需要改变 class 文件并添加 lazy 代理来解决延迟加载。

    OneToOne 的最佳实践是什么？

        1、Java 面向对象的设计原则：开闭原则。

        2、CascadeType 很强大，建议保持默认。

        3、所有用到关联关系的地方，能用 Lazy 的绝对不要用 EAGER，否则会有 SQL 性能问题，会出现不是预期的 SQL。

    JoinCloumns & JoinColumn

        这两个注解是单个集合关系，他们可以同时使用，@JoinColumn 表示单字段，@JoinCloumns 表示多个 @JoinColumn。

        public @interface JoinColumn {
            //关键的字段名,默认注解上的字段名，在@OneToOne代表本表的外键字段名字；
            String name() default "";
            //与name相反关联对象的字段，默认主键字段
            String referencedColumnName() default "";
            //外键字段是否唯一
            boolean unique() default false;
            //外键字段是否允许为空
            boolean nullable() default true;
            //是否跟随一起新增
            boolean insertable() default true;
            //是否跟随一起更新
            boolean updatable() default true;
            //JPA2.1新增，外键策略
            ForeignKey foreignKey() default @ForeignKey(PROVIDER_DEFAULT);
        }
        public enum ConstraintMode {
            //创建外键约束
           CONSTRAINT,
            //不创建外键约束
           NO_CONSTRAINT,
           //采用默认行为
           PROVIDER_DEFAULT
        }

        JoinCloumns 举例如下:

        @Entity
        public class CompanyOffice {
           @ManyToOne(fetch = FetchType.LAZY)
           @JoinColumns({
                 @JoinColumn(name="ADDR_ID", referencedColumnName="ID"),
                 @JoinColumn(name="ADDR_ZIP", referencedColumnName="ZIP")
           })
           private Address address;
        }

    @ManyToOne& @OneToMany

        @ManyToOne 代表多对一的关联关系，而 @OneToMany 代表一对多，一般两个成对使用表示双向关联关系。而 JPA 协议中也是明确规定：维护关联关系的是拥有外键的一方，而另一方必须配置 mappedBy。

        public @interface ManyToOne {
            Class targetEntity() default void.class;
            CascadeType[] cascade() default {};
            FetchType fetch() default EAGER;
            boolean optional() default true;
        }

        public @interface OneToMany {
            Class targetEntity() default void.class;
            //cascade 级联操作策略：(CascadeType.PERSIST、CascadeType.REMOVE、CascadeType.REFRESH、CascadeType.MERGE、CascadeType.ALL) 如果不填，默认关系表不会产生任何影响。
            CascadeType[] cascade() default {};
            //数据获取方式EAGER(立即加载)/LAZY(延迟加载)
            FetchType fetch() default LAZY;
            //关系被谁维护，单项的。注意：只有关系维护方才能操作两者的关系。
            String mappedBy() default "";
            //是否级联删除。和CascadeType.REMOVE的效果一样。两种配置了一个就会自动级联删除
            boolean orphanRemoval() default false;
        }

        OneToMany 和 ManyToOne 注意点:
            1、@ManyToOne 一定是维护外键关系的一方，所以没有 mappedBy 字段。

            2、@ManyToOne 删除的时候一定不能把 One 的一方删除了，所以也没有 orphanRemoval 的选项。

            3、@ManyToOne 的 Lazy 效果和 @OneToOne 的一样，所以和上面的用法基本一致。

            4、@OneToMany 的 Lazy 是有效果的。

        @Entity
        @Data
        @Builder
        @AllArgsConstructor
        @NoArgsConstructor
        public class User implements Serializable {
           @Id
           @GeneratedValue(strategy= GenerationType.AUTO)
           private Long id;
           private String name;
           private String email;
           private String sex;
           @OneToMany(mappedBy = "user",fetch = FetchType.LAZY)
           private List<UserAddress> address;
        }

        @Entity
        @Data
        @Builder
        @AllArgsConstructor
        @NoArgsConstructor
        @ToString(exclude = "user")
        public class UserAddress {
           @Id
           @GeneratedValue(strategy= GenerationType.AUTO)
           private Long id;
           private String address;
           @ManyToOne(cascade = CascadeType.ALL)
           private User user;
        }

        import com.fasterxml.jackson.core.JsonProcessingException;
        import org.assertj.core.util.Lists;
        import org.junit.jupiter.api.BeforeAll;
        import org.junit.jupiter.api.Test;
        import org.junit.jupiter.api.TestInstance;
        import org.springframework.beans.factory.annotation.Autowired;
        import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
        import org.springframework.test.annotation.Rollback;
        import javax.transaction.Transactional;
        @DataJpaTest
        @TestInstance(TestInstance.Lifecycle.PER_CLASS)
        public class UserAddressRepositoryTest {
           @Autowired
           private UserAddressRepository userAddressRepository;
           @Autowired
           private UserRepository userRepository;
           /**
            * 负责添加数据
            */
           @BeforeAll
           @Rollback(false)
           @Transactional
           void init() {
              User user = User.builder().name("jackxx").email("123456@126.com").build();
              UserAddress userAddress = UserAddress.builder().address("shanghai1").user(user).build();
              UserAddress userAddress2 = UserAddress.builder().address("shanghai2").user(user).build();
              userAddressRepository.saveAll(Lists.newArrayList(userAddress,userAddress2));
           }
           /**
            * 测试用User关联关系操作
            * @throws JsonProcessingException
            */
           @Test
           @Rollback(false)
           public void testUserRelationships() throws JsonProcessingException {
              User user = userRepository.getOne(2L);
              System.out.println(user.getName());
              System.out.println(user.getAddress());
           }
        }

    @ManyToOne 的 lazy 机制和用法，与 @OneToOne 的一样。而 @ManyToOne 和 @OneToMany 的最佳实践，与 @OneToOne 的完全一样，也是尽量避免双向关联，一切级联更新和 orphanRemoval 都保持默认规则，并且 fetch 采用 lazy 延迟加载。

    @ManyToMany

        @ManyToMany 代表多对多的关联关系，这种关联关系任何一方都可以维护关联关系。

        import lombok.*;
        import javax.persistence.*;
        import java.io.Serializable;
        import java.util.List;
        @Entity
        @Data
        @Builder
        @AllArgsConstructor
        @NoArgsConstructor
        public class User{
           @Id
           @GeneratedValue(strategy= GenerationType.AUTO)
           private Long id;
           private String name;
           @ManyToMany(mappedBy = "users")
           private List<Room> rooms;
        }

        Room 维护映射关系
        import lombok.*;
        import javax.persistence.*;
        import java.util.List;
        @Entity
        @Data
        @Builder
        @AllArgsConstructor
        @NoArgsConstructor
        @ToString(exclude = "users")
        public class Room {
           @Id
           @GeneratedValue(strategy = GenerationType.AUTO)
           private Long id;
           private String title;
           @ManyToMany
           private List<User> users;
        }

    当用到 @ManyToMany 的时候一定是三张表，不要想着建两张表，两张表肯定是违背表的设计原则的。

    public @interface ManyToMany {
        Class targetEntity() default void.class;
        CascadeType[] cascade() default {};
        FetchType fetch() default LAZY;
        String mappedBy() default "";
    }

    修改Room来定义中间表的表名称，中间字段，如下:
    @Entity
    @Data
    @Builder
    @AllArgsConstructor
    @NoArgsConstructor
    @ToString(exclude = "users")
    public class Room {
       @Id
       @GeneratedValue(strategy = GenerationType.AUTO)
       private Long id;
       private String title;
       @ManyToMany
       @JoinTable(name = "user_room_ref",
             joinColumns = @JoinColumn(name = "room_id_x"),
             inverseJoinColumns = @JoinColumn(name = "user_id_x")
       )
       private List<User> users;
    }

    public @interface JoinTable {
        //中间关联关系表明
        String name() default "";
        //表的catalog
        String catalog() default "";
        //表的schema
        String schema() default "";
        //维护关联关系一方的外键字段的名字
        JoinColumn[] joinColumns() default {};
        //另一方的表外键字段
        JoinColumn[] inverseJoinColumns() default {};
        //指定维护关联关系一方的外键创建规则
        ForeignKey foreignKey() default @ForeignKey(PROVIDER_DEFAULT);
        //指定另一方的外键创建规则
        ForeignKey inverseForeignKey() default @Forei gnKey(PROVIDER_DEFAULT);
    }

    如何利用ManyToOne和OneToMany 表示ManyToMany？

    新建中间表UserRoomRelation:
    import lombok.*;
    import javax.persistence.*;
    import java.util.Date;
    @Entity
    @Data
    @Builder
    @AllArgsConstructor
    @NoArgsConstructor
    public class UserRoomRelation {
       @Id
       @GeneratedValue(strategy = GenerationType.AUTO)
       private Long id;
       private Date createTime,udpateTime;
       @ManyToOne
       private Room room;
       @ManyToOne
       private User user;
    }

    public class User implements Serializable {
       @Id
       @GeneratedValue(strategy= GenerationType.AUTO)
       private Long id;
       @OneToMany(mappedBy = "user")
       private List<UserRoomRelation> userRoomRelations;
        ....
    }

    Room 变化如下：
    public class Room {
       @Id
       @GeneratedValue(strategy = GenerationType.AUTO)
       private Long id;
       @OneToMany(mappedBy = "room")
       private List<UserRoomRelation> userRoomRelations;
        ...
    }

    @ManyToMany 的最佳实践
    上面介绍的 @OneToMany 的最佳实践同样适用，采用的是双向关联，而实际生产一般是在中间表对象里面做单向关联，这样会让实体之间的关联关系简单很多。

    与 @OneToMany 一样的道理，不要用级联删除和 orphanRemoval=true。

    FetchType 采用默认方式：fetch = FetchType.LAZY 的方式。







